{
  "language": "Solidity",
  "sources": {
    "contracts/Employer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./Job.sol\";\n\n\ncontract Employers is Djob{\n\n    \n    /// @notice retrieves employer by address\n    /// @param _employer, address\n    /// @return props\n    function getEmployerByAddress(address _employer) external view returns(Employer memory props){\n        props = employers[_employer];\n    }\n\n    \n     /// @notice retrieves employer escrow balance\n    /// @param _employer, @param _job_id\n    /// @return uint\n    function getEmployerEscrow(address _employer, uint256 _job_id) external view returns(uint){\n        return escrowFunds[_employer][_job_id];\n\n    }\n\n     /// @notice process employer registration\n        /// @param _name , @param _industry\n      function registerEmployer\n      (string memory _name, string memory _industry,string memory _country, string memory _imageURI) public {\n        require(employers[msg.sender].registered == false, 'AR'); // already registered\n        require(bytes(_name).length > 0);\n        require(bytes(_industry).length > 0);\n        totalEmployers++;\n        employers[msg.sender] = Employer(msg.sender, _name, _industry, 0,_country, _imageURI,true,block.timestamp);\n        emit EmployerRegistered(msg.sender, _name);\n    }\n\n      /// @notice hiring freelancer and check if freelancer is not already hired for the job\n    /// @param jobId, @param freelancerAddress\n    function hireFreelancer(uint jobId, address freelancerAddress) public onlyEmployer(msg.sender) {\n        require(jobId <= totalJobs && jobId > 0, \"JDE.\"); // job does not exist\n        Job storage job = jobs[jobId];\n        require(job.employer != address(0), \"JNF\"); // Job not found\n        require(!isFreelancerHired(job, freelancerAddress), \"FAH\"); //Freelancer is already hired\n\n        job.hiredFreelancer = freelancerAddress;\n    \n    }\n\n}"
    },
    "contracts/Freelancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./Employer.sol\";\n\ncontract Dfreelancer is Employers { \n   \n\n     /// @notice retrieves freelancer by address\n    /// @param _freelancer, address\n    /// @return props\n    function getFreelancerByAddress(address _freelancer) external view returns(Freelancer memory props){\n        props = freelancers[_freelancer];\n    }\n\n    /// @notice process freelancer registration\n    /// @param _name , @param _skills\n    function registerFreelancer\n    (string memory _name, string memory _skills, string memory _country,\n    string memory _gigTitle, string memory _gigDesc, string[] memory _images, uint256 _starting_price) public {\n        require(freelancers[msg.sender].registered == false, 'AR'); // already registered\n        require(bytes(_name).length > 0);\n        require(bytes(_skills).length > 0);\n        totalFreelancers++;\n        freelancers[msg.sender] = Freelancer(msg.sender, _name, _skills, 0,_country, \n        _gigTitle,_gigDesc,_images,0,true,block.timestamp,_starting_price);\n        \n         // Add the freelancer address to the array\n        allFreelancerAddresses.push(msg.sender);\n\n        emit FreelancerRegistered(msg.sender, _images, _starting_price);\n        \n    }\n\n         /// @notice return all freelancers\n    function getAllFreelancers() public view returns (Freelancer[] memory) {\n        Freelancer[] memory allFreelancers = new Freelancer[](totalFreelancers);\n\n        for (uint256 i = 0; i < totalFreelancers; i++) {\n            allFreelancers[i] = freelancers[allFreelancerAddresses[i]];\n        }\n\n        return allFreelancers;\n    }\n\n    \n        /// @notice process employer funds deposit for a specific job\n        /// @param jobId , job id\n    function depositFunds(uint jobId) public payable {\n        require(jobId <= totalJobs && jobId > 0, \"JDE.\"); // job does not exist\n        Job storage job = jobs[jobId];\n        Employer storage employer = employers[msg.sender];\n        require(job.employer == msg.sender);\n        require(!job.completed, \"JAC\"); // Job is already completed.\n        require(msg.value >= job.budget, \"IA\"); // Insufficient amount\n        \n        employer.balance += msg.value;\n        escrowFunds[msg.sender][jobId] += msg.value;\n        emit FundsDeposited(jobId, msg.sender, msg.value);\n    }\n\n        /// @notice release escrow fund after successful completion of the job\n        /// @param jobId , @param freelancerAddress\n    function releaseEscrow(uint jobId, address freelancerAddress) public onlyEmployer(msg.sender){\n        require(jobId <= totalJobs && jobId > 0, \"JDE.\"); // job does not exist\n        Job storage job = jobs[jobId];\n        require(msg.sender == job.employer);\n        require(job.completed = true, \"JNC\"); // Job is not completed by freelancer\n\n        uint escrowAmount = escrowFunds[msg.sender][jobId];\n\n        require(escrowAmount > 0, \"NFE\"); // No funds in escrow\n        require(escrowAmount >= job.budget, \"IF\"); // insufficient funds\n        escrowFunds[msg.sender][jobId] = 0;        \n        // Implement logic to release funds from escrow to the freelancer's address\n        Freelancer storage freelancer = freelancers[freelancerAddress];\n        freelancer.balance += escrowAmount;\n        // update employer balance\n         Employer storage employer = employers[msg.sender];\n         employer.balance -= escrowAmount;\n         \n        emit FundsReleased(jobId, freelancerAddress, escrowAmount);\n    }\n\n\n    /// @notice process funds withdrawal to the freelancer after successful completion of a job\n    function withdrawEarnings() public onlyFreelancer(msg.sender) {\n       Freelancer storage freelancer = freelancers[msg.sender];\n        require(freelancer.balance > 0, \"NBW\"); // No balance to withdraw.\n\n        uint withdrawAmount = (freelancer.balance * 95) / 100; // 95% of balance\n        freelancer.balance = 0;\n\n        (bool success, ) = msg.sender.call{value: withdrawAmount}(\"\");\n        require(success, \"TF\"); // Transfer failed\n\n        emit WithdrawFund(msg.sender, withdrawAmount);\n    }\n}"
    },
    "contracts/Job.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Djob{\n     address public owner;\n    uint8 public totalJobs;\n    uint public totalFreelancers;\n    uint public totalEmployers;\n    uint public totalCompletedJobs;\n    address[] public allFreelancerAddresses;\n\n    struct Job {\n        uint8 id;\n        address employer;\n        string title;\n        string description;\n        uint256 budget;\n        bool completed;\n        address[] applicants;\n        address hiredFreelancer;        \n        \n    }\n\n    struct Freelancer {\n        address freelancerAddress;\n        string name;\n        string skills;\n        uint balance;\n        string country;\n        string gigTitle;\n        string gitDescription;\n        string[] images; // [0]= profileImage, [1]= gigImage\n        uint jobsCompleted;\n        bool registered;\n        uint256 registration_date;\n        uint256 starting_price;\n    }\n\n    \n    struct Employer {\n        address employerAddress;\n        string name;\n        string industry;\n        uint balance;\n        string country;\n        string image;\n        bool registered;\n        uint256 registration_date;\n\n    }\n\n    // Job[] public jobs;\n    mapping(uint256 => Job) jobs;\n\n    mapping(address => Freelancer) public freelancers;\n    mapping(address => Employer) public employers;\n    // mapping(address => bool) completedByFreelancers;\n    mapping(address => mapping(uint256 => uint)) escrowFunds;\n\n\n    event JobCreated(uint jobId, string title);\n    event FreelancerRegistered(address freelancerAddress, string[] name, uint256 amount);\n    event EmployerRegistered(address EmployerAddress, string name);\n    event JobCompleted(uint jobId, address freelancerAddress, uint payment);\n    event FundsDeposited(uint jobId, address sender, uint amount);\n    event FundsReleased(uint jobId, address freelancerAddress, uint amount);\n    event AppliedForJob(uint jobId, address employerAddress, address freelancerAddress);\n    event WithdrawFund(address freelancer, uint amount);\n\n\n    constructor() {\n        owner = msg.sender;\n    }\n    \n    modifier onlyEmployer(address _employerAddress){\n        require(employers[msg.sender].employerAddress == _employerAddress, \"OEF\"); // only employer can call this function\n\n        _;\n    }\n\n     modifier onlyFreelancer(address _freelancerAddress){\n        require(freelancers[msg.sender].freelancerAddress == _freelancerAddress, \"OFF\"); // only freelancer can call this function\n        _;\n    }\n\n     /// @notice job creation and increment job count,\n    /// @param _title, @param _description, @param _budget\n    function createJob(string memory _title, string memory _description, uint256 _budget) public onlyEmployer(msg.sender){\n        totalJobs++;\n        uint8 jobId = totalJobs;\n        jobs[jobId] = Job(jobId,payable(msg.sender),_title,_description,_budget,false,new address[](0),address(0));    \n        emit JobCreated(jobId, _title);\n    }\n\n    /// @notice retrieves job by ID\n    /// @param jobId, jobId\n    /// @return props\n     function getJobByID(uint256 jobId) external view returns(Job memory props) {\n        require(jobId > 0 && jobId <= totalJobs, \"IJ\"); //invalid job\n        props = jobs[jobId];\n    }\n\n    /// @notice retrieves all jobs\n    /// @return props\n    \n    function allJobs() external view returns(Job[] memory props){\n        props = new Job[](totalJobs);\n        for (uint i = 0; i < totalJobs; i++) {\n            props[i] = jobs[i + 1];\n        }\n\n    }\n\n\n      /// @notice job application\n    /// @param jobId, job id\n    function applyForJob(uint jobId) public {\n        require(jobId <= totalJobs && jobId > 0, \"JDE\"); // job does not exist\n        Job storage job = jobs[jobId];\n        require(job.employer != address(0), \"JNF\"); // Job not found\n        require(msg.sender != address(0), \"IA.\"); //invalid applicant\n\n        for (uint i = 0; i < job.applicants.length; i++) {\n            if (job.applicants[i] == msg.sender) {\n                revert(\"YHA\"); //You have already applied for this job.\n            }\n        }\n\n        job.applicants.push(msg.sender);\n\n        emit AppliedForJob(jobId,job.employer,msg.sender);\n    }\n\n    /// @notice process job completion\n    /// @param jobId, @param freelancerAddress\n    function completeJob(uint jobId, address freelancerAddress) public onlyEmployer(msg.sender) {\n        require(jobId <= totalJobs && jobId > 0, \"JDE\"); // job does not exist\n        Job storage job = jobs[jobId];\n        require(job.employer != address(0), \"JNF\"); // job not found\n        require(isFreelancerHired(job, freelancerAddress), \"FNH\"); //Freelancer is not hired for this job\n        // mark the job as completed\n        uint payment = job.budget;\n        job.completed = true;\n        totalCompletedJobs++;\n        freelancers[freelancerAddress].jobsCompleted++;\n        emit JobCompleted(jobId, freelancerAddress, payment);\n    }\n\n      /// @notice check if freelancer is hired\n        /// @param job , @param freelancerAddress\n        /// @return bool\n    function isFreelancerHired(Job storage job, address freelancerAddress) internal view returns (bool) {\n        if (job.hiredFreelancer == freelancerAddress) {\n            return true;\n        }\n        return false;\n    }\n\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}